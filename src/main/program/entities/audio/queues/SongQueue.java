package main.program.entities.audio.queues;

import lombok.Getter;
import main.program.commands.exceptions.InvalidOperation;
import main.program.databases.UserDatabase;
import main.program.entities.audio.collections.SongSource;
import main.program.entities.audio.files.AudioFile;
import main.program.entities.audio.files.Song;
import main.program.entities.audio.queues.repetition.RepeatChangeStrategy;
import main.program.entities.audio.queues.repetition.RepeatMode;
import main.program.entities.audio.queues.visitors.QueueVisitor;
import main.program.entities.users.User;

/**
 * A play queue consisting of songs (generated by a song or a playlist).
 */
@Getter
public final class SongQueue extends Queue {

    private final SongSource songSource;
    private final int size;

    public SongQueue(final User user, final SongSource songSource,
        final RepeatChangeStrategy repeatChangeStrategy) {
        super(user, repeatChangeStrategy);
        this.songSource = songSource;
        this.size = songSource.size();
        currentlyPlaying = getFilePlaying();
    }

    @Override
    protected Song getNextFile() {
        if (repeatMode == RepeatMode.REPEAT_CURRENT || repeatMode == RepeatMode.REPEAT_INFINITE) {
            return getFilePlaying();
        }

        if (repeatMode == RepeatMode.REPEAT_ONCE) {
            repeatMode = RepeatMode.NO_REPEAT;
            return getFilePlaying();
        }

        playIndex++;
        if (playIndex < songSource.size()) {
            return getFilePlaying();
        }

        if (repeatMode == RepeatMode.REPEAT_ALL) {
            playIndex = 0;
            return getFilePlaying();
        }

        return null;
    }

    private int getSongIndex(final int index) {
        return shuffler != null ? shuffler.getIndexMapping(index) : index;
    }

    @Override
    public Song getFilePlaying() {
        Song nowPlaying = songSource.get(getSongIndex(playIndex));
        if (nowPlaying != currentlyPlaying) {
            nowPlaying.addListen(user);
            user.addListen(nowPlaying);

            UserDatabase.getInstance().getMonetizedArtists().add(nowPlaying.getArtist());
        }

        return nowPlaying;
    }

    @Override
    public AudioFile prev() {
        if (playTime == 0 && playIndex != 0) {
            playIndex--;
            currentlyPlaying = getFilePlaying();
        }

        playTime = 0;
        return currentlyPlaying;
    }

    @Override
    public void skip(final int deltaTime) throws InvalidOperation {
        // `skip` is unsupported on this queue.
        throw new InvalidOperation();
    }

    /**
     * Accept a {@link QueueVisitor}.
     */
    @Override
    public void accept(final QueueVisitor visitor) {
        visitor.visit(this);
    }
}
